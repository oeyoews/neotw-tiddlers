> 为了防止数据丢失以及服务重启时能够恢复数据，Redis 支持数据的持久化，主要分为两种方式，分别是 RDB 和 AOF; 当然实际场景下还会使用这两种的混合模式。@pdai

* [Redis 进阶 - 持久化：RDB 和 AOF 机制详解](#redis%E8%BF%9B%E9%98%B6---%E6%8C%81%E4%B9%85%E5%8C%96rdb%E5%92%8Caof%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3)

  * [Redis 持久化简介](#redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AE%80%E4%BB%8B)

  * [RDB 持久化](#rdb-%E6%8C%81%E4%B9%85%E5%8C%96)

    * [触发方式](#%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F)

      * [手动触发](#%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91)
      * [自动触发](#%E8%87%AA%E5%8A%A8%E8%A7%A6%E5%8F%91)

    * [redis.conf 中配置 RDB](#redisconf%E4%B8%AD%E9%85%8D%E7%BD%AErdb)

    * [RDB 更深入理解](#rdb-%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3)

    * [RDB 优缺点](#rdb%E4%BC%98%E7%BC%BA%E7%82%B9)

  * [AOF 持久化](#aof-%E6%8C%81%E4%B9%85%E5%8C%96)

    * [如何实现 AOF](#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0aof)
    * [redis.conf 中配置 AOF](#redisconf%E4%B8%AD%E9%85%8D%E7%BD%AEaof)
    * [深入理解 AOF 重写](#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3aof%E9%87%8D%E5%86%99)

  * [RDB 和 AOF 混合方式（4.0 版本)](#rdb%E5%92%8Caof%E6%B7%B7%E5%90%88%E6%96%B9%E5%BC%8F40%E7%89%88%E6%9C%AC)

  * [从持久化中恢复数据](#%E4%BB%8E%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%AD%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE)

  * [性能与实践](#%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%9E%E8%B7%B5)

  * [参考文章](#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0)

## Redis 持久化简介

> 从两个点，我们来了解下 Redis 持久化

* **为什么需要持久化**？

Redis 是个基于内存的数据库。那服务一旦宕机，内存中的数据将全部丢失。通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复，1、会对数据库带来巨大的压力，2、数据库的性能不如 Redis。导致程序响应慢。所以对 Redis 来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。

* **Redis 持久化有哪些方式呢**？**为什么我们需要重点学 RDB 和 AOF**？

从严格意义上说，Redis 服务提供四种持久化存储方案：`RDB`、`AOF`、`虚拟内存（VM）`和　`DISKSTORE`。虚拟内存（VM）方式，从 Redis Version 2.4 开始就被官方明确表示不再建议使用，Version 3.2 版本中更找不到关于虚拟内存（VM）的任何配置范例，Redis 的主要作者 Salvatore Sanfilippo 还专门写了一篇论文，来反思 Redis 对虚拟内存（VM）存储技术的支持问题。

至于 DISKSTORE 方式，是从 Redis Version 2.8 版本开始提出的一个存储设想，到目前为止 Redis 官方也没有在任何 stable 版本中明确建议使用这用方式。在 Version 3.2 版本中同样找不到对于这种存储方式的明确支持。从网络上能够收集到的各种资料来看，DISKSTORE 方式和 RDB 方式还有着一些千丝万缕的联系，不过各位读者也知道，除了官方文档以外网络资料很多就是大抄。

最关键的是目前官方文档上能够看到的 Redis 对持久化存储的支持明确的就只有两种方案（https\://redis.io/topics/persistence）：RDB 和 AOF。所以本文也只会具体介绍这两种持久化存储方案的工作特定和配置要点。

## RDB 持久化

> RDB 就是 Redis DataBase 的缩写，中文名为快照 / 内存快照，RDB 持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。

### 触发方式

> 触发 rdb 持久化的方式有 2 种，分别是**手动触发**和**自动触发**。

#### 手动触发

> 手动触发分别对应 save 和 bgsave 命令

* **save 命令**：阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存 比较大的实例会造成长时间**阻塞**，线上环境不建议使用

* **bgsave 命令**：Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子 进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短

bgsave 流程图如下所示

![](https://pdai.tech/images/db/redis/redis-x-rdb-1.png)

具体流程如下：

* redis 客户端执行 bgsave 命令或者自动触发 bgsave 命令；
* 主进程判断当前是否已经存在正在执行的子进程，如果存在，那么主进程直接返回；
* 如果不存在正在执行的子进程，那么就 fork 一个新的子进程进行持久化数据，fork 过程是阻塞的，fork 操作完成后主进程即可执行其他操作；
* 子进程先将数据写入到临时的 rdb 文件中，待快照数据写入完成后再原子替换旧的 rdb 文件；
* 同时发送信号给主进程，通知主进程 rdb 持久化完成，主进程更新相关的统计信息（info Persitence 下的 rdb\_\* 相关选项）。

#### 自动触发

> 在以下 4 种情况时会自动触发

* redis.conf 中配置`save m n`，即在 m 秒内有 n 次修改时，自动触发 bgsave 生成 rdb 文件；

* 主从复制时，从节点要从主节点进行全量复制时也会触发 bgsave 操作，生成当时的快照发送到从节点；

* 执行 debug reload 命令重新加载 redis 时也会触发 bgsave 操作；

* 默认情况下执行 shutdown 命令时，如果没有开启 aof 持久化，那么也会触发 bgsave 操作；

### redis.conf 中配置 RDB

**快照周期**：内存快照虽然可以通过技术人员手动执行 SAVE 或 BGSAVE 命令来进行，但生产环境下多数情况都会设置其周期性执行条件。

* **Redis 中默认的周期新设置**

```
# 周期性执行条件的设置格式为
save <seconds> <changes>

# 默认的设置为：
save 900 1
save 300 10
save 60 10000

# 以下设置方式为关闭RDB快照功能
save ""
```

以上三项默认信息设置代表的意义是：

* 如果 900 秒内有 1 条 Key 信息发生变化，则进行快照；

* 如果 300 秒内有 10 条 Key 信息发生变化，则进行快照；

* 如果 60 秒内有 10000 条 Key 信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整。

* **其它相关配置**

```
# 文件名称
dbfilename dump.rdb

# 文件保存路径
dir /home/work/app/redis/data/

# 如果持久化出错，主进程是否停止写入
stop-writes-on-bgsave-error yes

# 是否压缩
rdbcompression yes

# 导入时是否检查
rdbchecksum yes
```

`dbfilename`：RDB 文件在磁盘上的名称。

`dir`：RDB 文件的存储路径。默认设置为 “./”，也就是 Redis 服务的主目录。

`stop-writes-on-bgsave-error`：上文提到的在快照进行过程中，主进程照样可以接受客户端的任何写操作的特性，是指在快照操作正常的情况下。如果快照操作出现异常（例如操作系统用户权限不够、磁盘空间写满等等）时，Redis 就会禁止写操作。这个特性的主要目的是使运维人员在第一时间就发现 Redis 的运行错误，并进行解决。一些特定的场景下，您可能需要对这个特性进行配置，这时就可以调整这个参数项。该参数项默认情况下值为 yes，如果要关闭这个特性，指定即使出现快照错误 Redis 一样允许写操作，则可以将该值更改为 no。

`rdbcompression`：该属性将在字符串类型的数据被快照到磁盘文件时，启用 LZF 压缩算法。Redis 官方的建议是请保持该选项设置为 yes，因为 “it’s almost always a win”。

`rdbchecksum`：从 RDB 快照功能的 version 5 版本开始，一个 64 位的 CRC 冗余校验编码会被放置在 RDB 文件的末尾，以便对整个 RDB 文件的完整性进行验证。这个功能大概会多损失 10% 左右的性能，但获得了更高的数据可靠性。所以如果您的 Redis 服务需要追求极致的性能，就可以将这个选项设置为 no。

### RDB 更深入理解

> 我们通过几个实战问题来深入理解 RDB

* **由于生产环境中我们为 Redis 开辟的内存区域都比较大（例如 6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间 Redis 服务一般都会收到数据写操作请求。那么如何保证数据一致性呢**？

RDB 中的核心思路是 Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面 Redis 主进程会 fork 一个新的快照进程专门来做这个事情，这样保证了 Redis 服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。

举个例子：如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

![](https://pdai.tech/images/db/redis/redis-x-aof-42.jpg)

* **在进行快照操作的这段时间，如果发生服务崩溃怎么办**？

很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的 RDB 快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis 服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。

* **可以每秒做一次快照吗**？

对于快照来说，所谓 “连拍” 就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。

如下图所示，我们先在 T0 时刻做了一次快照，然后又在 T0+t 时刻做了一次快照，在这期间，数据块 5 和 9 被修改了。如果在 t 这段时间内，机器宕机了，那么，只能按照 T0 时刻的快照进行恢复。此时，数据块 5 和 9 的修改值因为没有快照记录，就无法恢复了。 　　 ![](https://pdai.tech/images/db/redis/redis-x-rdb-2.jpg)

所以，要想尽可能恢复数据，t 值就要尽可能小，t 越小，就越像 “连拍”。那么，t 值可以小到什么程度呢，比如说是不是可以每秒做一次快照？毕竟，每次快照都是由 bgsave 子进程在后台执行，也不会阻塞主线程。

这种想法其实是错误的。虽然 bgsave 执行时不阻塞主线程，但是，**如果频繁地执行全量快照，也会带来两方面的开销**：

* 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
* 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁**阻塞主线程**了。

那么，有什么其他好方法吗？此时，我们可以做增量快照，就是指做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。这个比较好理解。

但是它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的**空间开销问题**。那么，还有什么方法既能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据呢？且看后文中 4.0 版本中引入的 RDB 和 AOF 的混合方式。

### RDB 优缺点

* **优点**

  * RDB 文件是某个时间节点的快照，默认使用 LZF 算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；
  * Redis 加载 RDB 文件恢复数据要远远快于 AOF 方式；

* **缺点**

  * RDB 方式实时性不够，无法做到秒级的持久化；
  * 每次调用 bgsave 都需要 fork 子进程，fork 子进程属于重量级操作，频繁执行成本较高；
  * RDB 文件是二进制的，没有可读性，AOF 文件在了解其结构的情况下可以手动修改或者补全；
  * 版本兼容 RDB 文件问题；

针对 RDB 不适合实时持久化的问题，Redis 提供了 AOF 持久化方式来解决

## AOF 持久化

> Redis 是 “写后” 日志，Redis 先执行命令，把数据写入内存，然后才记录日志。日志里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存。PS: 大多数的数据库采用的是写前日志（WAL），例如 MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

而 AOF 日志采用写后日志，即**先写内存，后写日志**。

![](https://pdai.tech/images/db/redis/redis-x-aof-41.jpg)

**为什么采用写后日志**？

Redis 要求高性能，采用写日志有两方面好处：

* **避免额外的检查开销**：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。
* 不会阻塞当前的写操作

但这种方式存在潜在风险：

* 如果命令执行完成，写日志之前宕机了，会丢失数据。
* 主线程写磁盘压力大，导致写盘慢，阻塞后续操作。

### 如何实现 AOF

AOF 日志记录 Redis 的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。

* **命令追加** 当 AOF 持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof\_buf 缓冲区。

* **文件写入和同步** 关于何时将 aof\_buf 缓冲区的内容写入 AOF 文件中，Redis 提供了三种写回策略：

![](https://pdai.tech/images/db/redis/redis-x-aof-4.jpg)

`Always`，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；

`Everysec`，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；

`No`，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

* **三种写回策略的优缺点**

上面的三种写回策略体现了一个重要原则：**trade-off**，取舍，指在性能和可靠性保证之间做取舍。

关于 AOF 的同步策略是涉及到操作系统的 write 函数和 fsync 函数的，在《Redis 设计与实现》中是这样说明的：

```
为了提高文件写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。

这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了fsync、fdatasync同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。
```

### redis.conf 中配置 AOF

默认情况下，Redis 是没有开启 AOF 的，可以通过配置 redis.conf 文件来开启 AOF 持久化，关于 AOF 的配置如下：

```
# appendonly参数开启AOF持久化
appendonly no

# AOF持久化的文件名，默认是appendonly.aof
appendfilename "appendonly.aof"

# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的
dir ./

# 同步策略
# appendfsync always
appendfsync everysec
# appendfsync no

# aof重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发配置
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 加载aof出错如何处理
aof-load-truncated yes

# 文件重写策略
aof-rewrite-incremental-fsync yes
```

以下是 Redis 中关于 AOF 的主要配置信息：

`appendonly`：默认情况下 AOF 功能是关闭的，将该选项改为 yes 以便打开 Redis 的 AOF 功能。

`appendfilename`：这个参数项很好理解了，就是 AOF 文件的名字。

`appendfsync`：这个参数项是 AOF 功能最重要的设置项之一，主要用于设置 “真正执行” 操作命令向 AOF 文件中同步的策略。

什么叫 “真正执行” 呢？还记得 Linux 操作系统对磁盘设备的操作方式吗？ 为了保证操作系统中 I/O 队列的操作效率，应用程序提交的 I/O 操作请求一般是被放置在 linux Page Cache 中的，然后再由 Linux 操作系统中的策略自行决定正在写到磁盘上的时机。而 Redis 中有一个 fsync () 函数，可以将 Page Cache 中待写的数据真正写入到物理设备上，而缺点是频繁调用这个 fsync () 函数干预操作系统的既定策略，可能导致 I/O 卡顿的现象频繁 。

与上节对应，appendfsync 参数项可以设置三个值，分别是：always、everysec、no，默认的值为 everysec。

`no-appendfsync-on-rewrite`：always 和 everysec 的设置会使真正的 I/O 操作高频度的出现，甚至会出现长时间的卡顿情况，这个问题出现在操作系统层面上，所有靠工作在操作系统之上的 Redis 是没法解决的。为了尽量缓解这个情况，Redis 提供了这个设置项，保证在完成 fsync 函数调用时，不会将这段时间内发生的命令操作放入操作系统的 Page Cache（这段时间 Redis 还在接受客户端的各种写操作命令）。

`auto-aof-rewrite-percentage`：上文说到在生产环境下，技术人员不可能随时随地使用 “BGREWRITEAOF” 命令去重写 AOF 文件。所以更多时候我们需要依靠 Redis 中对 AOF 文件的自动重写策略。Redis 中对触发自动重写 AOF 文件的操作提供了两个设置：auto-aof-rewrite-percentage 表示如果当前 AOF 文件的大小超过了上次重写后 AOF 文件的百分之多少后，就再次开始重写 AOF 文件。例如该参数值的默认设置值为 100，意思就是如果 AOF 文件的大小超过上次 AOF 文件重写后的 1 倍，就启动重写操作。

`auto-aof-rewrite-min-size`：参考 auto-aof-rewrite-percentage 选项的介绍，auto-aof-rewrite-min-size 设置项表示启动 AOF 文件重写操作的 AOF 文件最小大小。如果 AOF 文件大小低于这个值，则不会触发重写操作。注意，auto-aof-rewrite-percentage 和 auto-aof-rewrite-min-size 只是用来控制 Redis 中自动对 AOF 文件进行重写的情况，如果是技术人员手动调用 “BGREWRITEAOF” 命令，则不受这两个限制条件左右。

### 深入理解 AOF 重写

> AOF 会记录每个写命令到 AOF 文件，随着时间越来越长，AOF 文件会变得越来越大。如果不加以控制，会对 Redis 服务器，甚至对操作系统造成影响，而且 AOF 文件越大，数据恢复也越慢。为了解决 AOF 文件体积膨胀的问题，Redis 提供 AOF 文件重写机制来对 AOF 文件进行 “瘦身”。

* **图例解释 AOF 重写**

Redis 通过创建一个新的 AOF 文件来替换现有的 AOF，新旧两个 AOF 文件保存的数据相同，但新 AOF 文件没有了冗余命令。

![](https://pdai.tech/images/db/redis/redis-x-aof-1.jpg)

* **AOF 重写会阻塞吗**？

AOF 重写过程是由后台进程 bgrewriteaof 来完成的。主线程 fork 出后台的 bgrewriteaof 子进程，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。

所以 aof 在重写时，在 fork 进程时是会阻塞住主线程的。

* **AOF 日志何时会重写**？

有两个配置项控制 AOF 重写的触发：

`auto-aof-rewrite-min-size`: 表示运行 AOF 重写时文件的最小大小，默认为 64MB。

`auto-aof-rewrite-percentage`: 这个值的计算方式是，当前 aof 文件大小和上一次重写后 aof 文件大小的差值，再除以上一次重写后 aof 文件大小。也就是当前 aof 文件比上一次重写后 aof 文件的增量大小，和上一次重写后 aof 文件大小的比值。

* **重写日志时，有新数据写入咋整**？

重写过程总结为：“一个拷贝，两处日志”。在 fork 出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个 aof 日志内存缓冲区中。如果 AOF 写回策略配置的是 always，则直接将命令写回旧的日志文件，并且保存一份命令至 AOF 重写缓冲区，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：bgrewriteaof 进程使用的日志文件）

而在 bgrewriteaof 子进程完成会日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将 AOF 重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF 重写缓冲区积累可能会很大，这样就会造成阻塞，Redis 后来通过 Linux 管道技术让 aof 重写期间就能同时进行回放，这样 aof 重写结束后只需回放少量剩余的数据即可。

最后通过修改文件名的方式，保证文件切换的原子性。

在 AOF 重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。

**总结操作**：

* 主线程 fork 出子进程重写 aof 日志
* 子进程重写日志完成后，主线程追加 aof 日志缓冲
* 替换日志文件

温馨提示

这里的进程和线程的概念有点混乱。因为后台的 bgreweiteaof 进程就只有一个线程在操作，而主线程是 Redis 的操作进程，也是单独一个线程。这里想表达的是 Redis 主进程在 fork 出一个后台进程之后，后台进程的操作和主进程是没有任何关联的，也不会阻塞主线程。

![](https://pdai.tech/images/db/redis/redis-x-aof-2.jpg)

* **主线程 fork 出子进程的是如何复制内存数据的**？

fork 采用操作系统提供的写时复制（copy on write）机制，就是为了避免一次性拷贝大量内存数据给子进程造成阻塞。fork 子进程时，子进程时会拷贝父进程的页表，即虚实映射关系（虚拟内存和物理内存的映射索引表），而不会拷贝物理内存。这个拷贝会消耗大量 cpu 资源，并且拷贝完成前会阻塞主线程，阻塞时间取决于内存中的数据量，数据量越大，则内存页表越大。拷贝完成后，父子进程使用相同的内存地址空间。

但主进程是可以有数据写入的，这时候就会拷贝物理内存中的数据。如下图（进程 1 看做是主进程，进程 2 看做是子进程）：

![](https://pdai.tech/images/db/redis/redis-x-aof-3.png)

在主进程有数据写入时，而这个数据刚好在页 c 中，操作系统会创建这个页面的副本（页 c 的副本），即拷贝当前页的物理数据，将其映射到主进程中，而子进程还是使用原来的的页 c。

* **在重写日志整个过程时，主线程有哪些地方会被阻塞**？

1. fork 子进程时，需要拷贝虚拟页表，会对主线程阻塞。
2. 主进程有 bigkey 写入时，操作系统会创建页面的副本，并拷贝原有的数据，会对主线程阻塞。
3. 子进程重写日志完成后，主进程追加 aof 重写缓冲区时可能会对主线程阻塞。

* **为什么 AOF 重写不复用原 AOF 日志**？

两方面原因：

1. 父子进程写同一个文件会产生竞争问题，影响父进程的性能。
2. 如果 AOF 重写过程中失败了，相当于污染了原本的 AOF 文件，无法做恢复数据使用。

## RDB 和 AOF 混合方式（4.0 版本)

> Redis 4.0 中提出了一个**混合使用 AOF 日志和内存快照**的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。

如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。

![](https://pdai.tech/images/db/redis/redis-x-rdb-4.jpg)

这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，实际环境中用的很多。

## 从持久化中恢复数据

> 数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有 RDB 文件，又有 AOF 文件，该加载谁呢？

其实想要从这些文件中恢复数据，只需要重新启动 Redis 即可。我们还是通过图来了解这个流程：

![](https://pdai.tech/images/db/redis/redis-x-aof-5.png)

* redis 重启时判断是否开启 aof，如果开启了 aof，那么就优先加载 aof 文件；
* 如果 aof 存在，那么就去加载 aof 文件，加载成功的话 redis 重启成功，如果 aof 文件加载失败，那么会打印日志表示启动失败，此时可以去修复 aof 文件后重新启动；
* 若 aof 文件不存在，那么 redis 就会转而去加载 rdb 文件，如果 rdb 文件不存在，redis 直接启动成功；
* 如果 rdb 文件存在就会去加载 rdb 文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么 redis 重启成功，且使用 rdb 文件恢复数据；

那么为什么会优先加载 AOF 呢？因为 AOF 保存的数据更完整，通过上面的分析我们知道 AOF 基本上最多损失 1s 的数据。

## 性能与实践

通过上面的分析，我们都知道 RDB 的快照、AOF 的重写都需要 fork，这是一个重量级操作，会对 Redis 造成阻塞。因此为了不影响 Redis 主进程响应，我们需要尽可能降低阻塞。

* 降低 fork 的频率，比如可以手动来触发 RDB 生成快照、与 AOF 重写；
* 控制 Redis 最大使用内存，防止 fork 耗时过长；
* 使用更牛逼的硬件；
* 合理配置 Linux 的内存分配策略，避免因为物理内存不足导致 fork 失败。

在线上我们到底该怎么做？我提供一些自己的实践经验。

* 如果 Redis 中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；
* 自己制定策略定期检查 Redis 的情况，然后可以手动触发备份、重写数据；
* 单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO 资源竞争，让持久化变为串行；
* 可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；
* RDB 持久化与 AOF 持久化可以同时存在，配合使用。

## 参考文章

本文站在众多前人基础上完善而成，主要参考了如下文章：

* https\://www\.cnblogs.com/ybyn/p/14157568.html
* https\://segmentfault.com/a/1190000015983518
* https\://blog.csdn.net/qq\_41434612/article/details/108791437
* https\://www\.cnblogs.com/liang24/p/14180036.html
* https\://www\.jianshu.com/p/d3ba7b8ad964
* https\://blog.csdn.net/liupeifeng3514/article/details/79048767

同时还参考了

* 极客时间 《Redis 核心与实战》的相关内容

版权声明：遵循 CC 4.0 BY-SA 版权协议，转载请附上上面出处链接及本声明。
