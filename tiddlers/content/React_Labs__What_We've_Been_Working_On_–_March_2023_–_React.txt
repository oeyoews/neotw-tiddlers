March 22, 2023 by Joseph Savona, Josh Story, Lauren Tan, Mengdi Chen, Samuel Susla, Sathya Gunasekaran, Sebastian Markbåge, and Andrew Clark2023 年 3 月 22 日，作者：Joseph Savona、Josh Story、Lauren Tan、Mengdi Chen、Samuel Susla、Sathya Gunasekaran、Sebastian Markbåge 和 Andrew Clark

In React Labs posts, we write about projects in active research and development. We’ve made significant progress on them since our last update, and we’d like to share what we learned.在 React Labs 的帖子中，我们写了关于积极研究和开发的项目。自上次更新以来，我们已经在这些方面取得了重大进展，我们想分享我们学到的东西。

React Server Components  React 服务器组件
React Server Components (or RSC) is a new application architecture designed by the React team.React Server Components（或 RSC）是由 React 团队设计的一种新的应用程序架构。
We’ve first shared our research on RSC in an introductory talk and an RFC. To recap them, we are introducing a new kind of component—Server Components—that run ahead of time and are excluded from your JavaScript bundle. Server Components can run during the build, letting you read from the filesystem or fetch static content. They can also run on the server, letting you access your data layer without having to build an API. You can pass data by props from Server Components to the interactive Client Components in the browser.我们首先在介绍性演讲和 RFC 中分享了我们对 RSC 的研究。回顾一下，我们引入了一种新的组件 - 服务器组件 - 它提前运行，并且被排除在 JavaScript 包之外。服务器组件可以在构建期间运行，允许您从文件系统中读取或获取静态内容。它们还可以在服务器上运行，让您无需构建 API 即可访问数据层。您可以通过 props 将数据从服务器组件传递到浏览器中的交互式客户端组件。
RSC combines the simple“request/response”mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds.RSC 将以服务器为中心的多页应用程序的简单“请求/响应”心智模型与以客户端为中心的单页应用程序的无缝交互性相结合，为您提供两全其美的服务。
Since our last update, we have merged the React Server Components RFC to ratify the proposal. We resolved outstanding issues with the React Server Module Conventions proposal, and reached consensus with our partners to go with the "use client" convention. These documents also act as specification for what an RSC-compatible implementation should support.自上次更新以来，我们已经合并了 React Server 组件 RFC 以批准该提案。我们解决了 React Server 模块约定提案的悬而未决的问题，并与我们的合作伙伴达成了共识。 "use client" 这些文档还充当了 RSC 兼容实现应支持的内容的规范。
The biggest change is that we introduced async / await as the primary way to do data fetching from Server Components. We also plan to support data loading from the client by introducing a new Hook called use that unwraps Promises. Although we can’t support async / await in arbitrary components in client-only apps, we plan to add support for it when you structure your client-only app similar to how RSC apps are structured.最大的变化是，我们引入了 async / await 作为从服务器组件获取数据的主要方法。我们还计划通过引入一个名为 unwrap Promise 的新 Hook use 来支持从客户端加载数据。尽管我们无法支持 async / await 仅限客户端应用中的任意组件，但我们计划在构建仅限客户端的应用时添加对它的支持，类似于 RSC 应用的结构方式。
Now that we have data fetching pretty well sorted, we’re exploring the other direction: sending data from the client to the server, so that you can execute database mutations and implement forms. We’re doing this by letting you pass Server Action functions across the server/client boundary, which the client can then call, providing seamless RPC. Server Actions also give you progressively enhanced forms before JavaScript loads.现在我们已经很好地整理了数据获取，我们正在探索另一个方向：将数据从客户端发送到服务器，以便您可以执行数据库突变并实现表单。为此，我们允许您跨服务器/客户端边界传递服务器操作函数，然后客户端可以调用这些函数，从而提供无缝的 RPC。服务器操作还会在加载 JavaScript 之前为您提供逐步增强的表单。
React Server Components has shipped in Next.js App Router. This showcases a deep integration of a router that really buys into RSC as a primitive, but it’s not the only way to build a RSC-compatible router and framework. There’s a clear separation for features provided by the RSC spec and implementation. React Server Components is meant as a spec for components that work across compatible React frameworks.React 服务器组件已在 Next.js App Router 中提供。这展示了路由器的深度集成，它真正将 RSC 作为基元购买，但这并不是构建与 RSC 兼容的路由器和框架的唯一方法。RSC 规范和实现提供的功能有明确的分离。React Server Components 旨在作为跨兼容 React 框架工作的组件的规范。
We generally recommend using an existing framework, but if you need to build your own custom framework, it is possible. Building your own RSC-compatible framework is not as easy as we’d like it to be, mainly due to the deep bundler integration needed. The current generation of bundlers are great for use on the client, but they weren’t designed with first-class support for splitting a single module graph between the server and the client. This is why we’re now partnering directly with bundler developers to get the primitives for RSC built-in.我们通常建议使用现有框架，但如果需要构建自己的自定义框架，则可以使用。构建自己的 RSC 兼容框架并不像我们希望的那么容易，主要是由于需要深度打包器集成。当前一代的打包器非常适合在客户端上使用，但它们在设计时并没有提供一流的支持，无法在服务器和客户端之间拆分单个模块图。这就是为什么我们现在直接与打包器开发人员合作，以获得内置 RSC 的原语。
Asset Loading  资产加载
Suspense lets you specify what to display on the screen while the data or code for your components is still being loaded. This lets your users progressively see more content while the page is loading as well as during the router navigations that load more data and code. However, from the user’s perspective, data loading and rendering do not tell the whole story when considering whether new content is ready. By default, browsers load stylesheets, fonts, and images independently, which can lead to UI jumps and consecutive layout shifts.Suspense 允许您指定在加载组件的数据或代码时在屏幕上显示的内容。这样一来，用户在加载页面时以及在加载更多数据和代码的路由器导航期间，可以逐步看到更多内容。但是，从用户的角度来看，在考虑新内容是否准备就绪时，数据加载和呈现并不能说明全部情况。默认情况下，浏览器独立加载样式表、字体和图像，这可能会导致 UI 跳转和连续布局偏移。
We’re working to fully integrate Suspense with the loading lifecycle of stylesheets, fonts, and images, so that React takes them into account to determine whether the content is ready to be displayed. Without any change to the way you author your React components, updates will behave in a more coherent and pleasing manner. As an optimization, we will also provide a manual way to preload assets like fonts directly from components.我们正在努力将 Suspense 与样式表、字体和图像的加载生命周期完全集成，以便 React 考虑它们以确定内容是否准备好显示。在不改变你创作 React 组件的方式的情况下，更新将以更连贯和令人愉悦的方式运行。作为优化，我们还将提供一种直接从组件预加载字体等资产的手动方法。
We are currently implementing these features and will have more to share soon.我们目前正在实现这些功能，并将很快分享更多功能。
Document Metadata  文档元数据
Different pages and screens in your app may have different metadata like the <title> tag, description, and other <meta> tags specific to this screen. From the maintenance perspective, it’s more scalable to keep this information close to the React component for that page or screen. However, the HTML tags for this metadata need to be in the document <head> which is typically rendered in a component at the very root of your app.应用中的不同页面和屏幕可能具有不同的元数据，例如特定于此屏幕的 <title> 标记、说明和其他 <meta> 标记。从维护的角度来看，将此信息保持在该页面或屏幕的 React 组件附近更具可扩展性。但是，此元数据的 HTML 标记需要位于文档中，该文档 <head> 通常呈现在应用最根目录的组件中。
Today, people solve this problem with one of the two techniques.今天，人们使用两种技术之一来解决这个问题。
One technique is to render a special third-party component that moves <title>, <meta>, and other tags inside it into the document <head>. This works for major browsers but there are many clients which do not run client-side JavaScript, such as Open Graph parsers, and so this technique is not universally suitable.一种技术是渲染一个特殊的第三方组件，该组件将其中的、 <meta> 和其他标签移动到 <title> 文档 <head> 中。这适用于主流浏览器，但有许多客户端不运行客户端 JavaScript，例如 Open Graph 解析器，因此这种技术并不普遍适用。
Another technique is to server-render the page in two parts. First, the main content is rendered and all such tags are collected. Then, the <head> is rendered with these tags. Finally, the <head> and the main content are sent to the browser. This approach works, but it prevents you from taking advantage of the React 18’s Streaming Server Renderer because you’d have to wait for all content to render before sending the <head>.另一种技术是将页面分成两部分进行服务器呈现。首先，呈现主要内容并收集所有此类标签。然后，使用这些标记呈现。 <head> 最后，将 <head> 和 主要内容发送到浏览器。这种方法有效，但它会阻止您利用 React 18 的 Streaming Server Renderer，因为您必须等待所有内容渲染完毕，然后才能发送 <head> .
This is why we’re adding built-in support for rendering <title>, <meta>, and metadata <link> tags anywhere in your component tree out of the box. It would work the same way in all environments, including fully client-side code, SSR, and in the future, RSC. We will share more details about this soon.这就是为什么我们添加了内置支持，用于在组件树中的任何位置呈现 <title> 、 <meta> 和元数据 <link> 标记。它将在所有环境中以相同的方式工作，包括完全客户端代码、SSR 以及将来的 RSC。我们将很快分享有关此的更多详细信息。
React Optimizing Compiler React 优化编译器
Since our previous update we’ve been actively iterating on the design of React Forget, an optimizing compiler for React. We’ve previously talked about it as an“auto-memoizing compiler”, and that is true in some sense. But building the compiler has helped us understand React’s programming model even more deeply. A better way to understand React Forget is as an automatic reactivity compiler.自上次更新以来，我们一直在积极迭代 React Forget（React 的优化编译器）的设计。我们之前曾将其称为“自动记忆编译器”，从某种意义上说，这是正确的。但是构建编译器帮助我们更深入地理解了 React 的编程模型。理解 React Forget 的更好方法是作为一个自动反应式编译器。
The core idea of React is that developers define their UI as a function of the current state. You work with plain JavaScript values — numbers, strings, arrays, objects — and use standard JavaScript idioms — if/else, for, etc — to describe your component logic. The mental model is that React will re-render whenever the application state changes. We believe this simple mental model and keeping close to JavaScript semantics is an important principle in React’s programming model.React 的核心思想是开发人员将他们的 UI 定义为当前状态的函数。您可以使用纯 JavaScript 值（数字、字符串、数组、对象）并使用标准的 JavaScript 习惯用语（if/else、for 等）来描述组件逻辑。心智模型是，每当应用程序状态发生变化时，React 都会重新渲染。我们相信这种简单的心智模型和接近 JavaScript 语义是 React 编程模型中的一个重要原则。
The catch is that React can sometimes be too reactive: it can re-render too much. For example, in JavaScript we don’t have cheap ways to compare if two objects or arrays are equivalent (having the same keys and values), so creating a new object or array on each render may cause React to do more work than it strictly needs to. This means developers have to explicitly memoize components so as to not over-react to changes.问题在于，React 有时可能过于被动：它可以重新渲染太多。例如，在 JavaScript 中，我们没有廉价的方法来比较两个对象或数组是否等效（具有相同的键和值），因此在每次渲染上创建一个新对象或数组可能会导致 React 完成比它严格需要的更多的工作。这意味着开发人员必须明确地记住组件，以免对更改反应过度。
Our goal with React Forget is to ensure that React apps have just the right amount of reactivity by default: that apps re-render only when state values meaningfully change. From an implementation perspective this means automatically memoizing, but we believe that the reactivity framing is a better way to understand React and Forget. One way to think about this is that React currently re-renders when object identity changes. With Forget, React re-renders when the semantic value changes — but without incurring the runtime cost of deep comparisons.我们对 React Forget 的目标是确保 React 应用在默认情况下具有恰到好处的反应性：只有当状态值发生有意义的变化时，应用才会重新渲染。从实现的角度来看，这意味着自动记忆，但我们认为响应式框架是理解 React 和 Forget 的更好方法。一种思考方式是，当对象身份发生变化时，React 当前会重新渲染。使用 Forget，React 会在语义值发生变化时重新渲染，但不会产生深度比较的运行时成本。
In terms of concrete progress, since our last update we have substantially iterated on the design of the compiler to align with this automatic reactivity approach and to incorporate feedback from using the compiler internally. After some significant refactors to the compiler starting late last year, we’ve now begun using the compiler in production in limited areas at Meta. We plan to open-source it once we’ve proved it in production.在具体进展方面，自上次更新以来，我们对编译器的设计进行了实质性的迭代，以与这种自动反应方法保持一致，并在内部纳入使用编译器的反馈。从去年年底开始对编译器进行了一些重大重构之后，我们现在已经开始在 Meta 的有限区域使用编译器。我们计划在生产中证明它后将其开源。
Finally, a lot of people have expressed interest in how the compiler works. We’re looking forward to sharing a lot more details when we prove the compiler and open-source it. But there are a few bits we can share now:最后，很多人对编译器的工作方式表示了兴趣。我们期待在证明编译器并开源时分享更多细节。但是我们现在可以分享一些信息：
The core of the compiler is almost completely decoupled from Babel, and the core compiler API is (roughly) old AST in, new AST out (while retaining source location data). Under the hood we use a custom code representation and transformation pipeline in order to do low-level semantic analysis. However, the primary public interface to the compiler will be via Babel and other build system plugins. For ease of testing we currently have a Babel plugin which is a very thin wrapper that calls the compiler to generate a new version of each function and swap it in.编译器的核心几乎与 Babel 完全分离，核心编译器 API（大致）是旧的 AST 输入，新的 AST 输出（同时保留源位置数据）。在后台，我们使用自定义代码表示和转换管道来进行低级语义分析。但是，编译器的主要公共接口将通过 Babel 和其他构建系统插件。为了便于测试，我们目前有一个 Babel 插件，它是一个非常薄的包装器，它调用编译器来生成每个函数的新版本并将其交换。
As we refactored the compiler over the last few months, we wanted to focus on refining the core compilation model to ensure we could handle complexities such as conditionals, loops, reassignment, and mutation. However, JavaScript has a lot of ways to express each of those features: if/else, ternaries, for, for-in, for-of, etc. Trying to support the full language up-front would have delayed the point where we could validate the core model. Instead, we started with a small but representative subset of the language: let/const, if/else, for loops, objects, arrays, primitives, function calls, and a few other features. As we gained confidence in the core model and refined our internal abstractions, we expanded the supported language subset. We’re also explicit about syntax we don’t yet support, logging diagnostics and skipping compilation for unsupported input. We have utilities to try the compiler on Meta’s codebases and see what unsupported features are most common so we can prioritize those next. We’ll continue incrementally expanding towards supporting the whole language.在过去的几个月里，当我们重构编译器时，我们希望专注于优化核心编译模型，以确保我们能够处理条件、循环、重新分配和突变等复杂性。然而，JavaScript 有很多方法来表达这些特性：if/else、三元、for、for-in、for-of 等。如果试图预先支持完整的语言，那么我们验证核心模型的时间就会延迟。取而代之的是，我们从该语言的一个很小但具有代表性的子集开始：let/const、if/else、for 循环、对象、数组、基元、函数调用和其他一些功能。随着我们对核心模型的信心增强并完善了内部抽象，我们扩展了支持的语言子集。我们还明确了我们还不支持的语法，记录诊断并跳过不支持的输入的编译。我们有实用程序可以在 Meta 的代码库上试用编译器，看看哪些不受支持的功能是最常见的，以便我们接下来可以优先考虑这些功能。我们将继续逐步扩展以支持整个语言。
Making plain JavaScript in React components reactive requires a compiler with a deep understanding of semantics so that it can understand exactly what the code is doing. By taking this approach, we’re creating a system for reactivity within JavaScript that lets you write product code of any complexity with the full expressivity of the language, instead of being limited to a domain specific language.要使 React 组件中的纯 JavaScript 具有响应式，需要编译器对语义有深刻的理解，以便它能够准确地理解代码在做什么。通过采用这种方法，我们正在创建一个 JavaScript 中的响应式系统，让您能够编写具有语言完整表现力的任何复杂程度的产品代码，而不是局限于特定领域的语言。
Offscreen Rendering  屏幕外渲染
Offscreen rendering is an upcoming capability in React for rendering screens in the background without additional performance overhead. You can think of it as a version of the content-visibility CSS property that works not only for DOM elements but React components, too. During our research, we’ve discovered a variety of use cases:屏幕外渲染是 React 中即将推出的一项功能，用于在后台渲染屏幕，而不会产生额外的性能开销。你可以把它看作是 CSS 属性的一个版本，它不仅适用于 DOM 元素，content-visibility 也适用于 React 组件。在我们的研究中，我们发现了各种用例：

A router can prerender screens in the background so that when a user navigates to them, they’re instantly available.路由器可以在后台预渲染屏幕，以便当用户导航到它们时，它们可以立即使用。
A tab switching component can preserve the state of hidden tabs, so the user can switch between them without losing their progress.选项卡切换组件可以保留隐藏选项卡的状态，因此用户可以在它们之间切换而不会丢失进度。
A virtualized list component can prerender additional rows above and below the visible window.虚拟化列表组件可以预呈现可见窗口上方和下方的其他行。
When opening a modal or popup, the rest of the app can be put into“background”mode so that events and updates are disabled for everything except the modal.打开模式或弹出窗口时，可以将应用程序的其余部分置于“后台”模式，以便对除模式之外的所有内容禁用事件和更新。

Most React developers will not interact with React’s offscreen APIs directly. Instead, offscreen rendering will be integrated into things like routers and UI libraries, and then developers who use those libraries will automatically benefit without additional work.大多数 React 开发人员不会直接与 React 的屏幕外 API 交互。取而代之的是，屏幕外渲染将被集成到路由器和 UI 库等内容中，然后使用这些库的开发人员将自动受益，而无需额外的工作。
The idea is that you should be able to render any React tree offscreen without changing the way you write your components. When a component is rendered offscreen, it does not actually mount until the component becomes visible — its effects are not fired. For example, if a component uses useEffect to log analytics when it appears for the first time, prerendering won’t mess up the accuracy of those analytics. Similarly, when a component goes offscreen, its effects are unmounted, too. A key feature of offscreen rendering is that you can toggle the visibility of a component without losing its state.这个想法是，你应该能够在不改变编写组件的方式的情况下在屏幕外渲染任何 React 树。当组件在屏幕外渲染时，它实际上不会挂载，直到组件变得可见 - 其效果不会触发。例如，如果组件在首次出现时用于 useEffect 日志分析，则预呈现不会破坏这些分析的准确性。同样，当组件离开屏幕时，其效果也会被卸载。屏幕外渲染的一个关键功能是，您可以在不丢失其状态的情况下切换组件的可见性。
Since our last update, we’ve tested an experimental version of prerendering internally at Meta in our React Native apps on Android and iOS, with positive performance results. We’ve also improved how offscreen rendering works with Suspense — suspending inside an offscreen tree will not trigger Suspense fallbacks. Our remaining work involves finalizing the primitives that are exposed to library developers. We expect to publish an RFC later this year, alongside an experimental API for testing and feedback.自上次更新以来，我们已经在 Android 和 iOS 上的 React Native 应用中测试了 Meta 内部预渲染的实验版本，并取得了积极的性能结果。我们还改进了屏外渲染与 Suspense 的配合方式 - 在屏外树中挂起不会触发 Suspense 回退。我们剩下的工作是最终确定向库开发人员公开的原语。我们预计将在今年晚些时候发布 RFC，以及用于测试和反馈的实验性 API。
Transition Tracing  转换跟踪
The Transition Tracing API lets you detect when React Transitions become slower and investigate why they may be slow. Following our last update, we have completed the initial design of the API and published an RFC. The basic capabilities have also been implemented. The project is currently on hold. We welcome feedback on the RFC and look forward to resuming its development to provide a better performance measurement tool for React. This will be particularly useful with routers built on top of React Transitions, like the Next.js App Router.Transition Tracing API 可让您检测 React Transitions 何时变慢，并调查它们可能变慢的原因。在上次更新之后，我们已经完成了 API 的初始设计并发布了 RFC。基本功能也已实现。该项目目前处于搁置状态。我们欢迎对 RFC 的反馈，并期待恢复其开发，为 React 提供更好的性能衡量工具。这对于构建在 React Transitions 之上的路由器特别有用，例如 Next.js App Router。

In addition to this update, our team has made recent guest appearances on community podcasts and livestreams to speak more on our work and answer questions.除了此更新之外，我们的团队最近还客串了社区播客和直播，以更多地介绍我们的工作并回答问题。

Dan Abramov and Joe Savona were interviewed by Kent C. Dodds on his YouTube channel, where they discussed concerns around React Server Components.Dan Abramov 和 Joe Savona 在他的 YouTube 频道上接受了 Kent C. Dodds 的采访，他们讨论了对 React 服务器组件的担忧。
Dan Abramov and Joe Savona were guests on the JSParty podcast and shared their thoughts about the future of React.Dan Abramov 和 Joe Savona 是 JSParty 播客的嘉宾，他们分享了他们对 React 未来的看法。

Thanks to Andrew Clark, Dan Abramov, Dave McCabe, Luna Wei, Matt Carroll, Sean Keegan, Sebastian Silbermann, Seth Webster, and Sophie Alpert for reviewing this post.感谢 Andrew Clark、Dan Abramov、Dave McCabe、Luna Wei、Matt Carroll、Sean Keegan、Sebastian Silbermann、Seth Webster 和 Sophie Alpert 对本文的审阅。
Thanks for reading, and see you in the next update! 感谢您的阅读，下次更新见！