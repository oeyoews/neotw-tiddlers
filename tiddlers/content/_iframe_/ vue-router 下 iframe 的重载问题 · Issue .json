[
    {
        "text": "最近项目中需要使用到内嵌网页，最开始本来是考虑使用 `webview` 标签，但是 👉\n\n> Electron 的 `webview` 标签基于 [Chromium webview \\</0>](https://developer.chrome.com/docs/extensions/reference/webviewTag/) ，后者正在经历巨大的架构变化。 这将影响 `webview` 的稳定性，包括呈现、导航和事件路由。 我们目前建议不使用 `webview` 标签，并考虑其他替代方案，如 `iframe` 、Electron 的 `BrowserView` 或完全避免嵌入内容的体系结构。\n\n而 `BrowserView` 则是由 Electron 主进程控制，调用成本较高，并且是置于窗口的最顶层，会覆盖父窗口的 tooltip，效果不理想，最后就只有 `iframe` 可供使用。但是使用过程中发现，当路由切换后，iframe 会重载，里面的所有状态都会重置。首先想到 vue-router 的问题，当切换回路由时组件重新渲染，导致 iframe 重载。但项目由于要保存路由状态，使用了 `keep-alive`。\n\n`<keep-alive>` 本质上它就是去缓存已经创建过的 `vnode`，而缓存的 `vnode` 对象也会持有 DOM，因此 DOM 并不会销毁。既然 DOM 还是原来的 DOM，那为什么 `iframe` 中的内容会重载呢 😢。试着在 vue-router 的 issue 下查找关于 iframe 的问题，基本都是 [route with iframe changes the iframe then the page when hitting back](https://github.com/vuejs/vue-router/issues/2403) 之类的问题，没有较好的解决方案。\n\n最后在看了下 [MDN 上关于 `iframe` 的介绍](https://developer.mozilla.org/zh-cn/docs/web/html/element/iframe) ：\n\n> **HTML 内联框架元素 (`<iframe>`)** 表示嵌套的 [browsing context](https://developer.mozilla.org/en-US/docs/Glossary/browsing_context)。它能够将另一个 HTML 页面嵌入到当前页面中。\\\n> 每个嵌入的浏览上下文（embedded browsing context）都有自己的会话历史记录 (session history) 和 **DOM 树**。包含嵌入内容的浏览上下文称为 *父级浏览上下文*。顶级浏览上下文（没有父级）通常是由 `Window` 对象表示的浏览器窗口。\n\n莫非 iframe 的加载和所在 DOM 树也有关系？首先看看 iframe 的 load 时机：\n\n```\n(() => {\n  const el = document.createElement('iframe');\n  el.onload = () => console.log('el load', el);\n  el.src = 'http://nodejs.cn/';\n  setTimeout(() => {\n    document.documentElement.appendChild(el);\n    console.log('body append el -> ', el);\n  }, 5000);\n})();\n```\n\n[![image](https://user-images.githubusercontent.com/31235016/105283696-f1f8f900-5beb-11eb-97cd-b8462dc52c9d.png)](https://user-images.githubusercontent.com/31235016/105283696-f1f8f900-5beb-11eb-97cd-b8462dc52c9d.png)\n\n可以看到在 `iframe` 被插入 `document` 之后才触发 load 事件，而同为 [可替换元素](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element) 的 img 元素则是在更新 `src` 属性后就会触发 load 事件，可能就是因为这个 `browsing context` 和所在 DOM 树有关。\n\n现在来模拟一下 vue-router 中使用 `keep-alive` 的情况：\n\n```\n<button id=\"remove\">remove</button> <button id=\"append\">append</button>\n<hr />\n<main>\n  <iframe\n    id=\"iframe\"\n    src=\"http://nodejs.cn/\"\n    width=\"100%\"\n    height=\"600px\"\n    frameborder=\"0\"\n  ></iframe>\n</main>\n<script>\n  const $iframe = document.querySelector('#iframe');\n  const $remove = document.querySelector('#remove');\n  const $append = document.querySelector('#append');\n  const $main = $iframe.parentNode;\n  $remove.onclick = () => $iframe.remove();\n  $append.onclick = () => $main.appendChild($iframe);\n  $iframe.addEventListener('load', (e) => {\n    console.log('load ->', e);\n  });\n</script>\n```\n\n在离开路由时，iframe 会从 DOM 树中移除，但依然会保留在 vNode 中，不会被垃圾回收机制回收掉。这里点击 remove 按钮移除并保存在变量 `$iframe` 中。\\\n然后进入路由后，通过 vNode 的缓存重新将元素节点插回 DOM 树中。这里点击 append 按钮插到 `<main>` 节点下。\n\n[![image](https://user-images.githubusercontent.com/31235016/105284707-fa523380-5bed-11eb-9471-036a735e8589.png)](https://user-images.githubusercontent.com/31235016/105284707-fa523380-5bed-11eb-9471-036a735e8589.png)\n\n可以看到在进入页面后 load 一次，执行以上操作之后又 load 了一次。\\\n我们 remove 操作前后在控制台输入 `$iframe.contentWindow` ，\n\n[![image](https://user-images.githubusercontent.com/31235016/105284888-4f8e4500-5bee-11eb-80e3-34c3617570a4.png)](https://user-images.githubusercontent.com/31235016/105284888-4f8e4500-5bee-11eb-80e3-34c3617570a4.png)\n\n发现 iframe 在离开 DOM 树后 window 对象为 null，可以说明子窗口已被销毁，通过对比也可以发现前后两个 window 并不相同。\n\n回到最开始的问题，如何在 vue-router 下使用 iframe 并在切换路由时不重载？\\\n首先 `keep-alive` 是必须使用的，保证组件状态不变。iframe 元素加载后不能脱离 DOM 树，这里考虑在将 iframe 所在的节点移动到 `document.documentElement` 下，再去通过 css 修改元素的位置（这里我使用`position: fixed;` 控制位置，`z-index` 控制显示层级）以及显示状态。\n\n```\n// 使用 v-show=\"active\" 来控制 this.$refs.xxx 的显示\nexport default {\n  data() {\n    return {\n      active: true,\n    };\n  },\n\n  activated() {\n    this.active = true;\n  },\n\n  deactivated() {\n    this.active = false;\n  },\n\n  mounted() {\n    document.documentElement.appendChild(this.$refs.xxx);\n  },\n\n  beforeDestroy() {\n    document.documentElement.removeChild(this.$refs.xxx);\n  },\n};\n```\n",
        "creator": "oeyoews",
        "type": "text/markdown",
        "url": "https://github.com/canvascat/note/issues/12",
        "created": "20240814074018000",
        "modified": "20240814074018000",
        "tags": "剪藏",
        "title": "<iframe>/ vue-router 下 iframe 的重载问题 · Issue "
    }
]