[
    {
        "text": "本题我重点从防抖的作用、概念应用场景、手写防抖函数方面回答，同时通过防抖和节流的区别，加深自己对防抖和节流知识点的理解。\n\n## 一、概念\n\n## （一）防抖 (debounce) 的概念\n\n防抖是触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法。\\\n[![image](https://user-images.githubusercontent.com/20392340/58331393-a10b8d00-7e6b-11e9-8639-5c5c42502b90.png)](https://user-images.githubusercontent.com/20392340/58331393-a10b8d00-7e6b-11e9-8639-5c5c42502b90.png)\n\n## （二）节流 (throttle) 的概念\n\n节流是高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。每次触发事件时，如果当前有等待执行的延时函数，则直接 return。\\\n[![image](https://user-images.githubusercontent.com/20392340/58331493-dc0dc080-7e6b-11e9-822d-5a3a1bc64025.png)](https://user-images.githubusercontent.com/20392340/58331493-dc0dc080-7e6b-11e9-822d-5a3a1bc64025.png)\n\n## 二、作用\n\n## （一）防抖的作用\n\n如果我们对函数的调用频率无限制，比如在实现模糊查询的时候，既会加重浏览器的负担，也会加重服务器的负担，防抖可以减少函数的调用频率，不影响功能的情况下，提升用户体验。\n\n## （二）节流的作用\n\n节流就是在一定时间间隔内触发一次事件。减少触发事件的频率，提升性能。\n\n## 三、防抖 (debounce) 和节流 (throttle) 的区别\n\n函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，列入水管的水滴在一定的间隔时间滴一滴水。而函数防抖只是在最后一次事件后才触发一次函数，如果中途再次触发，则再次重新开始计算时间，重新延迟。\n\n## 四、应用场景\n\n## （一）防抖的应用场景\n\n### 1、模糊查询\n\n## （二）节流的应用场景\n\n### 1、滚动页面\n\n## 五、手写代码\n\n## （一）手写防抖\n\n通过定义一个是否执行函数的 canRun 标识，在没有超过约定时间内，如果再次触发函数，清除定时器，重新计算时间，直到到了约定时间后，才会调用函数。比如在实现模糊查询的时候，每个 500ms 向后台发起一个请求\n\n* 实现思路\\\n  每次调用函数时，先清除定时器，重新计算时间，直到满足约定的时间后，再清除定时器\n\n```\nfunction debounce(fn, wait) {\n    var timeout = null;\n    return function() {\n        if(timeout !== null) {\n          clearTimeout(timeout);\n        }\n        timeout = setTimeout(fn, wait);\n    }\n}\n// 处理函数\nfunction handle() {\n    console.log(Math.random()); \n}\n// 滚动事件\nwindow.addEventListener('scroll', debounce(handle, 1000));\n```\n\n\\##（二）手写节流\n\n* 实现思路\\\n  调用函数时，通过上一次 pre 和现在 now 两个变量，记录调用时间的频率，prev-now 如果大于约定的时间，才调用函数。调用函数结束后，把 pre 设置为现在的时间。\n\n```\n var throttle = function(func, delay) {\n            var prev = Date.now();\n            return function() {\n                var context = this;\n                var args = arguments;\n                var now = Date.now();\n                if (now - prev >= delay) {\n                    func.apply(context, args);\n                    prev = Date.now();\n                }\n            }\n        }\n        function handle() {\n            console.log(Math.random());\n        }\n        window.addEventListener('scroll', throttle(handle, 1000));\n```\n\n## 六、参考文章\n\n* [【JS 的节流和防抖】](https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA)\n\n> 结语\\\n> 我的回答如有不对的地方，麻烦务必指出来，我及时改正，以免误导别人，让我们共同进步吧！\n",
        "creator": "oeyoews",
        "type": "text/markdown",
        "url": "https://github.com/YvetteLau/Step-By-Step/issues/10",
        "created": "20240706163132000",
        "modified": "20240706163132000",
        "tags": "剪藏",
        "title": "防抖(debounce)函数的作用是什么？有哪些应用场景，请实现一个防抖函数。 · Issue "
    }
]